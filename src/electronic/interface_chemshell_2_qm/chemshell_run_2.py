#! /usr/bin/env python2

from __future__ import absolute_import
import shutil
import multiprocessing

from .chemshell_create_2 import *
from .chemshell_parser_2 import *
from io import open


class chemshell_run_2(object):
    def __init__(self, config={}):

        self.config = config

        root_dir = config['root']
        dirs = config['dirs']
        files = config['files']
        self.file_chemshell_orca_tcl = root_dir + "/" + dirs[
            'template'] + "/" + files['chemshell_orca_tcl']
        self.file_chemshell_qchem_tcl = root_dir + "/" + dirs[
            'template'] + "/" + files['chemshell_qchem_tcl']
        self.file_chemshell_mndo_tcl = root_dir + "/" + dirs[
            'template'] + "/" + files['chemshell_mndo_tcl']
        self.file_chemshell_prmtop = root_dir + "/" + dirs[
            'template'] + "/" + files['chemshell_prmtop']
        self.file_chemshell_inpcrd = root_dir + "/" + dirs[
            'template'] + "/" + files['chemshell_inpcrd']
        self.file_chemshell_template = root_dir + "/" + dirs[
            'template'] + "/" + files['chemshell_template']

        self.file_chemshell_wfu = root_dir + "/" + dirs['home'] + "/" + files[
            'chemshell_wfu']

        self.file_interface = files['interface']
        self.file_chemshell_input = files['chemshell_input']
        self.file_chemshell_log = files['chemshell_log']

        self.directory = {}
        self.directory['root'] = root_dir
        self.directory['template'] = root_dir + "/" + dirs['template']
        self.directory['home'] = root_dir + "/" + dirs['home']
        self.directory['work'] = self.directory['home'] + "/" + dirs['work']

        dyn = tools.load_data(files['dyn'])
        self.qm_method = int(dyn['quantum']['qm_method'])
        self.qm_package = int(dyn['quantum']['qm_package'])

        interface = tools.load_data(self.file_interface)
        self.it = int(interface['parm']['i_time'])

        # run the job directly
        self.worker()

        return

    def initilize(self):
        """
        check interface & determine the implimented module to be called.
        """
        # make directory
        # @ Check & Remove the old working directory for QC calc.

        home_dir = self.directory['home']

        if not os.path.exists(home_dir):
            os.makedirs(home_dir)

        destPath = self.directory['work']
        tempPath = self.directory['template']

        if not os.path.exists(destPath):
            os.makedirs(destPath)

        if os.path.exists(destPath):
            filelist = os.listdir(destPath)
            for i_file in filelist:
                file_path = destPath + '/' + i_file
                if os.path.isfile(file_path):
                    os.remove(file_path)

        sourceFile = self.file_chemshell_orca_tcl
        if os.path.isfile(sourceFile):
            shutil.copy2(sourceFile, destPath)

        sourceFile = self.file_chemshell_qchem_tcl
        if os.path.isfile(sourceFile):
            shutil.copy2(sourceFile, destPath)

        sourceFile = self.file_chemshell_mndo_tcl
        if os.path.isfile(sourceFile):
            shutil.copy2(sourceFile, destPath)

        sourceFile = self.file_chemshell_wfu
        if os.path.isfile(sourceFile):
            shutil.copy2(sourceFile, destPath + '/orca1.gbw')

        sourceFile = self.file_chemshell_prmtop
        if os.path.isfile(sourceFile):
            shutil.copy2(sourceFile, destPath)

        sourceFile = self.file_chemshell_inpcrd
        if os.path.isfile(sourceFile):
            shutil.copy2(sourceFile, destPath)

        sourceFile = self.file_chemshell_template
        destpath_chm = destPath + '/' + self.file_chemshell_input
        shutil.copy2(sourceFile, destpath_chm)

        if self.qm_package == 307:
            if self.it == 0:
                exec_name = "sed -i '/SCF_GUESS/d' " + destpath_chm + " \n"
                print exec_name
                os.system(exec_name)

        sourceFile = self.file_interface
        if os.path.isfile(sourceFile):
            shutil.copy2(sourceFile, destPath)
        else:
            print 'Check the interface file generated by main code!\n'
            exit(1)

        self.destPath = destPath

        return

    def prepare(self):
        """
        generate chemshell input file
        based on template (user) or parameter (auto)
        """
        # read template & create input chemshell file
        chemshell = chemshell_create_2(self.config)
        chemshell.wrt_chemshell_input()

        return

    def run(self):
        """
        call the QC code & confirm the running is ok. if not throw error messages.
        """

        exec_name = self.config['command']['chemshell']
        jobin = self.file_chemshell_input
        jobout = self.file_chemshell_log

        if self.qm_package == 307:
            currdir = os.getcwdu()
            #      set qchem environment

            QCSCRATCH = currdir + "/QCSCRATCH"
            QCLOCALSCR = currdir + "/QCLOCALSCR"

            if os.path.exists(QCSCRATCH):

                os.system("rm -rf " + str(QCSCRATCH))

            if os.path.exists(QCLOCALSCR):

                os.system("rm -rf " + str(QCLOCALSCR))

            os.makedirs(QCSCRATCH)
            os.makedirs(QCLOCALSCR)

            exec_name1 = "export QCSCRATCH=" + QCSCRATCH
            exec_name2 = "export QCLOCALSCR=" + QCLOCALSCR
            exec_name3 = exec_name + " " + jobin + ' > ' + jobout
            exec_name_all = exec_name1 + " && " + exec_name2 + " && " + exec_name3
        else:
            exec_name_all = exec_name + " " + jobin + ' > ' + jobout

        print exec_name_all + '\n'
        os.system(exec_name_all)

        return

    def check_excited_state_order(self):

        os.chdir(self.destPath_1)

        file_in = open('qchem.log', 'r')
        line_all = file_in.read()
        file_in.close()
        line_each = line_all.split('\n')
        n_Line = len(line_each)

        STATE_S2_all = []
        for cur_line in line_each:
            i_find_STATE_DERIV = re.search('CIS_STATE_DERIV', cur_line)
            if i_find_STATE_DERIV is not None:
                STATE_DERIV_1 = int(cur_line.split()[1])

            i_find_S2 = re.search('<S\*\*2>', cur_line)
            if i_find_S2 is not None:
                STATE_S2 = float(cur_line.split()[2])
                STATE_S2_all.append(STATE_S2)

        singlet_state_all = []
        i_tmp = 0
        for i_s2 in STATE_S2_all:
            i_tmp = i_tmp + 1
            if i_s2 < 1.2:
                singlet_state_all.append(i_tmp)

        os.chdir(self.destPath_2)

        file_in = open('qchem.log', 'r')
        line_all = file_in.read()
        file_in.close()
        line_each = line_all.split('\n')
        n_Line = len(line_each)

        for cur_line in line_each:
            i_find_STATE_DERIV = re.search('CIS_STATE_DERIV', cur_line)
            if i_find_STATE_DERIV is not None:
                STATE_DERIV_2 = int(cur_line.split()[1])

        print STATE_S2_all
        print STATE_DERIV_1
        print STATE_DERIV_2
        print singlet_state_all

        if STATE_DERIV_1 == singlet_state_all[
                0] and STATE_DERIV_2 == singlet_state_all[1]:
            self.order_changed = False
        else:
            self.order_changed = True
            self.STATE_DERIV_1 = STATE_DERIV_1
            self.STATE_DERIV_2 = STATE_DERIV_2
            self.singlet_state_all = singlet_state_all

        os.chdir(self.config['root'])

    def modify_excited_state_order(self):

        exec_name = "sed -i 's/CIS_STATE_DERIV  " + self.STATE_DERIV_1 + "/CIS_STATE_DERIV  " + self.singlet_state_all[
            0] + "/g' " + self.file_chemshell_state_1
        print exec_name + '\n'
        os.system(exec_name)

        exec_name = "sed -i 's/CIS_STATE_DERIV  " + self.STATE_DERIV_2 + "/CIS_STATE_DERIV  " + self.singlet_state_all[
            1] + "/g' " + self.file_chemshell_state_2
        print exec_name + '\n'
        os.system(exec_name)

    def analyze(self):
        """
        extract data used for mecp opt, 
        the required QC information was extraced.
        """

        chemshell = chemshell_parser_2(self.config)
        chemshell.get_log_dat()

        return

    def finalize(self):
        """
        simply clean up the tmp dat. and so on.
        """
        sourcePath = self.directory['work']

        sourceFile = sourcePath + '/' + 'qm_results.dat'
        destPath = self.directory['root']

        shutil.copy2(sourceFile, destPath)

        sourcePath = self.directory['work']
        sourceFile = sourcePath + '/orca1.gbw'
        if os.path.isfile(sourceFile):
            destFile = self.file_chemshell_wfu1
            shutil.copy2(sourceFile, destFile)

        print 'Finish QC calculation\n'

        return

    def all_work(self):

        self.initilize()

        os.chdir(self.directory['work'])
        self.prepare()
        self.run()
        os.chdir(self.directory['root'])

        return

    def worker(self):
        """
        wrap the whole process
        """

        if self.qm_method == 21:

            self.all_work()

            self.analyze()
            self.finalize()

        if self.qm_method == 22:

            self.all_work()

            self.analyze()
            self.finalize()

        if self.qm_method == 23:

            self.all_work()

            self.check_excited_state_order()

            if self.order_changed is True:
                print "The excited state order is changed!\n"

                self.modify_excited_state_order()

                self.all_work()

            self.analyze()
            self.finalize()

        return

    # Main Program


if __name__ == "__main__":
    mr = chemshell_run()
    mr.worker()
