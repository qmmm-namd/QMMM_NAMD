#! /usr/bin/env python
import sys
import os
import copy
import shutil
import math

sys.path.append("../../ci_overlap/tools/")
import tools

# @ 2015.03.31
# @ Du L.
# @ qibebt
# @
# I want to implemented various non-pbc boundary condition
# the first version is aimed at qm/mm dynamics
# to maintain the solvent boundary
#
#
# 1st version
# constraints the specific atom list, with given atom id
#
#
# ref_coord
#

class constraints():
    def __init__(self, config = {}):
        self.config = config

        self.files = {'ref_internal': 'ref_coord.json', \
                      }
        self.vars = {}
        self.vars['force_constant'] = 1.0e3
        self.vars['ref_info'] = {}
        
        return

    def read_ref_coord(self, filename = "ref_coord"):
        """ reference coord. & frozen dimension """
        fp = open(filename, "r")
        # number of site
        line = fp.readline().strip()
        n_site = int(line)
        # title
        line = fp.readline()
        coord = []
        name = []
        frozen = []
        # read coord
        for i in xrange(n_site):
            line = fp.readline()
            record = line.split()
            n_col = len(record[4:])
            c = [float(f) for f in record[1:4]]
            if n_col == 1:
                ndx = [int(record[4]) for i in xrange(3)]
            elif n_col == 3:
                ndx = [int(d) for d in record[4:7]]
            else:
                print("Error: read failed, ref_coord, check ref_coord !!!")
                exit(1)
            name.append(record[0])
            coord.append(c)
            frozen.append(ndx)
        self.vars['ref_info'] = \
        {'name': name, 'coord': coord, 'frozen': frozen, 'n_site': n_site}
        
        tools.dump_data(self.files['ref_internal'], self.vars['ref_info'])

        return

    def read_curr_coord(self, filename = "curr_coord"):
        """ current coord. & frozen dimension """
        fp = open(filename, "r")
        # number of site
        line = fp.readline().strip()
        n_site = int(line)
        # title
        line = fp.readline()
        coord = []
        name = []
        # read coord
        for i in xrange(n_site):
            line = fp.readline()
            record = line.split()
            n_col = len(record)
            c = [float(f) for f in record[1:4]]
            name.append(record[0])
            coord.append(c)
            self.vars['curr_info'] = {'name': name, 'coord': coord, 'n_site': n_site}
        
        return


    def load_coord(self):
        """
        load two set of coord. of the system
        """
        self.read_ref_coord()
        self.read_curr_coord()
        
        return

        
    def read_cons_atom_id(self):
        """ read cons atom info. """
        filename = "cons_atom_id"
        fp = open(filename, "r")
        atom_id_list = []
        while True:
            line = fp.readline()
            if line.strip() == "":
                break
            record = line.split()
            atom_id_list.extend([int(i) for i in record])
        self.vars['cons_atom_id'] = atom_id_list
        
        return

    def read_gradient(self):
        """ read in gradient """
        # backup no-constrainted grad. info.
        sourceFile = self.files['gradient']
        destFile = "./" + self.files['gradient'] + ".bak"
        if os.path.isfile(sourceFile):
            shutil.copy2(sourceFile, destFile)
        else :
            print 'Check the interface template file generated by dynamics code!'
            exit(1)                    
        fp = open(sourceFile, "r")
        grad = []
        i_atom = 0
        while True:
            line = fp.readline()
            if line.strip() == "":
                break
            i_atom += 1
            record = line.split()
            t = [float(s) for s in record]
            grad.append(t)
        self.vars['oldgrad'] = grad
        self.vars['n_atom'] = i_atom
        return

    def harmonic_3d(self, p, p0, k, ndx):
        """
        given a point P and a reference point P0,
        calculate the harmonic restrant value and gradients
        grad = 2 k r * (x/r)
        """
        f = 0.0
        g = []
 
        # x direction
        dx = p[0] - p0[0]
        if ndx[0] != 0:
            f += k * dx * dx
            t = 2.0 * k * dx
            g.append(t)
        else:
            g.append(0.0)
        # y direction
        dx = p[1] - p0[1]
        if ndx[1] != 0:
            f += k * dx * dx
            t = 2.0 * k * dx
            g.append(t)
        else:
            g.append(0.0)

        # z direction
        dx = p[2] - p0[2]
        if ndx[2] != 0:
            f += k * dx * dx
            t = 2.0 * k * dx
            g.append(t)
        else:
            g.append(0.0)

        return f, g

    
    def get_cons_eandg(self):
        """
        the energy & force for this constraints action
        """
        k = self.vars['force_constant']
        curr_info = self.vars['curr_info']
        ref_info = self.vars['ref_info']
        n_site = curr_info['n_site']
        
        curr_coord = curr_info['coord']
        ref_coord = ref_info['coord']
        ref_frozen = ref_info['frozen']

        ene = 0.0
        grad = [[0.0 for j in xrange(3)] for i in xrange(n_site)]
        for i in xrange(n_site):
            ndx = ref_frozen[i]
            s = sum(ndx)
            if s == 0:
                continue
            p = curr_coord[i]
            p0 = ref_coord[i]
            f, g = self.harmonic_3d(p, p0, k, ndx)
            ene += f; grad[i] = g
        self.vars['energy'] = ene
        self.vars['gradient'] = grad
        
        return

    def write_cons_eandg(self):
        """
        dump energy and gradient of the cons.
        """
        ene = self.vars['energy']
        grad = self.vars['gradient']
        # dump cons. energy
        fp = open("cons_energy.dat", "w")
        print >>fp, "%20.12f" % ene
        fp.close()
        fp = open("cons_gradient.dat", "w")
        for g in grad:
            print >>fp, "%20.12f%20.12f%20.12f" % (g[0], g[1], g[2])
        fp.close()
        return


    def modify(self):
        """
        add up to non-cons force
        """
        n_atom = self.vars['n_atom']        
        newgrad = [[0.0 for j in xrange(3)] for i in xrange(n_atom)]
        oldgrad = self.vars['oldgrad']
        deltagrad = self.vars['deltagrad']
        for i in xrange(n_atom):
            newgrad[i][0] = oldgrad[i][0] + deltagrad[i][0]
            newgrad[i][1] = oldgrad[i][1] + deltagrad[i][1]
            newgrad[i][2] = oldgrad[i][2] + deltagrad[i][2]
        
        self.vars['newgrad'] = newgrad
        
        return

    
    def calc(self):
        """ constrain routine """
        self.load_coord()
        self.get_cons_eandg()
        self.write_cons_eandg()

        return
    
                 
if __name__ == "__main__":
    c = constraints()
    c.calc()


    exit()
